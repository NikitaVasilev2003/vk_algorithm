# Профильное задание

## Текст задания

Нужно написать код для поиска в лабиринте самого быстрого пути из одной точки в другую.

Лабиринт состоит из клеток и представлен числами от 0 до 9 в виде двухмерного массива (матрицы), где числа от 1 до 9 означают длину пути при проходе через клетку, а 0 означает стену - то есть клетку, через которую пройти нельзя.
Перемещаться в лабиринте можно только по вертикали и горизонтали. Переходить сквозь границы лабиринта нельзя.

В результате должна получиться консольная программа, которая читает из стандартного ввода входные параметры, вычисляет результат и записывает его в стандартный вывод или при какой-либо ошибке записывает в стандартный вывод ошибок (STDERR) текст ошибки.

Формат входных параметров - текстовый, где каждый параметр отделяется переносом строки (как в обычном тексте).

Список входных параметров:
1. Размер лабиринта (два числа разделённых пробелом, означающих длину и ширину лабиринта).


2. Структура лабиринта (список строк с числами от 0 до 9; числа отделяются пробелами; строки - как в обычном тексте, отделяются переносами строк).


3. Две координаты клеток лабиринта - старт и финиш, где каждая координата состоит из двух чисел - индекс строки и индекс столбца, разделенных пробелами.

   Пример входных параметров:
```txt
   3 3
   1 2 0
   2 0 1
   9 1 0
   0 0 2 1
```
   после последнего параметра также должен быть перенос строки для обозначения конца входных параметров

   Формат результата - также текстовый, состоящий из списка координат клеток, через которые программа "проложила" кратчайший путь, а список координат разделён переносом строки; в конце списка выводится точка (в отдельной строке).

   Пример результата:
```txt
   0 0
   1 0
   2 0
   2 1
```
   первая строка - старт, последняя строка с числами - финиш. точка в конце нужна чтобы отделить результат от побочных данных, если захочется что-то ещё вывести, например, для отладки.


# Решение

Я использовал алгоритм 1-k BFS, потому что асимптотическая сложность 1-k BFS O(n + m) будет меньше сложности алгоритма Дейкстры. Реализиция на Python и Go.
## Описание алгоритма

### Преимущества

1. **Эффективная работа с ограниченными весами ребер**
   В данном случае веса ребер (значения клеток) варьируются от 0 до 9. Это позволяет эффективно применять модифицированный BFS для поиска кратчайшего пути, поскольку:
   - Алгоритм работает быстрее в условиях ограниченных весов.
   - Упрощается обработка данных.
   - Реализация становится более простой и удобной.

2. **Высокая скорость выполнения**
   Для фиксированных весов (от 0 до 9) мвременная сложность модифицированного BFS составляет \(O(V + E)\), где \(V\) — количество клеток, а \(E\) — количество переходов. В то же время Алгоритм Дейкстры — \(O((V + E)* logV)\).аким образом, модифицированный BFS оказывается более эффективным для задач с ограниченными весами.

### Заключение

Благодаря своей простоте, эффективности при работе с ограниченными весами и меньшей вычислительной сложности в таких условиях, модифицированный BFS является оптимальным выбором для данной задачи.
