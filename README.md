# Профильное задание

## Текст задания

Нужно написать код для поиска в лабиринте самого быстрого пути из одной точки в другую.

Лабиринт состоит из клеток и представлен числами от 0 до 9 в виде двухмерного массива (матрицы), где числа от 1 до 9 означают длину пути при проходе через клетку, а 0 означает стену - то есть клетку, через которую пройти нельзя.
Перемещаться в лабиринте можно только по вертикали и горизонтали. Переходить сквозь границы лабиринта нельзя.

В результате должна получиться консольная программа, которая читает из стандартного ввода входные параметры, вычисляет результат и записывает его в стандартный вывод или при какой-либо ошибке записывает в стандартный вывод ошибок (STDERR) текст ошибки.

Формат входных параметров - текстовый, где каждый параметр отделяется переносом строки (как в обычном тексте).

Список входных параметров:
1. Размер лабиринта (два числа разделённых пробелом, означающих длину и ширину лабиринта).


2. Структура лабиринта (список строк с числами от 0 до 9; числа отделяются пробелами; строки - как в обычном тексте, отделяются переносами строк).


3. Две координаты клеток лабиринта - старт и финиш, где каждая координата состоит из двух чисел - индекс строки и индекс столбца, разделенных пробелами.

   Пример входных параметров:
```txt
   3 3
   1 2 0
   2 0 1
   9 1 0
   0 0 2 1
```
   после последнего параметра также должен быть перенос строки для обозначения конца входных параметров

   Формат результата - также текстовый, состоящий из списка координат клеток, через которые программа "проложила" кратчайший путь, а список координат разделён переносом строки; в конце списка выводится точка (в отдельной строке).

   Пример результата:
```txt
   0 0
   1 0
   2 0
   2 1
```
   первая строка - старт, последняя строка с числами - финиш. точка в конце нужна чтобы отделить результат от побочных данных, если захочется что-то ещё вывести, например, для отладки.


# Решение

Я использовал алгоритм 1-k BFS, потому что асимптотическая сложность 1-k BFS O(n + m) будет меньше сложности алгоритма Дейкстры. Реализиция на Python и Go.
## Описание алгоритма для поиска кратчайшего пути

### Преимущества выбранного подхода

1. **Работа с ограниченными весами ребер:**
   В данной задаче веса ребер (величины клеток) лежат в пределах от 0 до 9. Это позволяет эффективно использовать модифицированный алгоритм BFS с несколькими уровнями очередей (`multi-level queue`) для поиска кратчайшего пути. В отличие от алгоритма Дейкстры, который требует использование приоритетной очереди (или кучи), наш алгоритм:
   - Работает быстрее для ограниченных весов.
   - Уменьшает сложность работы с данными.

2. **Простота реализации:**
   Использование BFS с уровнями требует меньше кода и проще в реализации, чем алгоритм Дейкстры. Это делает алгоритм более удобным для небольших задач, где веса ограничены сверху.

3. **Скорость выполнения:**
   Для фиксированных весов (от 0 до 9) модифицированный BFS выполняет операции с временем работы \(O(V + E)\), где \(V\) — количество клеток, а \(E\) — количество возможных переходов между клетками. Алгоритм Дейкстры, используя приоритетную очередь, имеет сложность \(O((V + E)* logV)\). Таким образом, в данной задаче BFS более эффективен.

4. **Необходимость только в кратчайшем пути:**
   В задаче требуется найти только кратчайший путь между двумя заданными точками. Нам не нужно находить кратчайшие пути ко всем вершинам, что делает использование алгоритма Дейкстры избыточным.

### Почему не используется обычный BFS?

Обычный BFS предполагает, что все ребра графа имеют одинаковый вес. Однако в данной задаче веса клеток различны, поэтому требуется учитывать их при подсчете расстояния. Модификация BFS с несколькими уровнями очередей позволяет корректно обрабатывать разницу в весах.

### Заключение

Модифицированный BFS является оптимальным выбором для данной задачи благодаря:
- Простоте реализации.
- Эффективной работе с ограниченными весами.
- Более низкой вычислительной сложности по сравнению с Дейкстрой в условиях ограниченных весов.
